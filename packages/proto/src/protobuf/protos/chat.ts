// @generated by protobuf-ts 2.5.0
// @generated from protobuf file "protobuf/protos/chat.proto" (package "socketProtos.chat", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType as MessageType$ } from "@protobuf-ts/runtime";
/**
 * Connect 訂閱賽事房間 cmd:ConnectRequestCode
 *
 * @generated from protobuf message socketProtos.chat.Connect
 */
export interface Connect {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string; // 聊天室房間唯一key}
/**
 * unSubcribeLiveRoom 離開賽事房間 取消訂閱
 *
 * @generated from protobuf message socketProtos.chat.unSubcribeLiveRoom
 */
export interface unSubcribeLiveRoom {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string; // 聊天室房間唯一key}
/**
 * PushMessage 傳送賽事房間訊息 cmd:PushMessageRequestCode
 *
 * @generated from protobuf message socketProtos.chat.PushMessage
 */
export interface PushMessage {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string; // 傳送訊息聊天室房間    /**
     * @generated from protobuf field: string msg = 3;
     */
    msg: string; // 傳送訊息內容    /**
     * @generated from protobuf field: socketProtos.chat.MessageType msgType = 4;
     */
    msgType: MessageType; // 訊息類別    /**
     * @generated from protobuf field: int32 hashUserId = 5;
     */
    hashUserId: number; // 直播 @user}
/**
 * NewMessageReply
 * 接收房間最新訊息 cmd:NewMessageReplyCode
 *
 * @generated from protobuf message socketProtos.chat.NewMessageReply
 */
export interface NewMessageReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string; // 接收訊息聊天室房間id    /**
     * @generated from protobuf field: socketProtos.chat.Message message = 3;
     */
    message?: Message;
    /**
     * @generated from protobuf field: socketProtos.chat.Room room = 4;
     */
    room?: Room;
}
/**
 * DelMessageReply
 * 刪除房間訊息 cmd:DelMessageReplyCode
 *
 * @generated from protobuf message socketProtos.chat.DelMessageReply
 */
export interface DelMessageReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string; // 刪除訊息聊天室房間id    /**
     * @generated from protobuf field: string msgId = 3;
     */
    msgId: string; // 訊息唯一key}
/**
 * ErrorMessageReply
 * 傳送訊息格式文字不符 cmd:NewMessageErrorReplyCode
 *
 * @generated from protobuf message socketProtos.chat.ErrorMessageReply
 */
export interface ErrorMessageReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: socketProtos.chat.Message message = 3;
     */
    message?: Message; // 傳送的訊息    /**
     * @generated from protobuf field: socketProtos.chat.newMsgErrorType errorCode = 4;
     */
    errorCode: newMsgErrorType; // 錯誤代碼    /**
     * @generated from protobuf field: socketProtos.chat.Room room = 5;
     */
    room?: Room;
}
/**
 * @generated from protobuf message socketProtos.chat.Message
 */
export interface Message {
    /**
     * @generated from protobuf field: string msgId = 1;
     */
    msgId: string; // 訊息唯一key    /**
     * @generated from protobuf field: string msgText = 2;
     */
    msgText: string; // 訊息內容    /**
     * @generated from protobuf field: socketProtos.chat.UserInfo fromUser = 3;
     */
    fromUser?: UserInfo; // 傳送訊息使用者    /**
     * @generated from protobuf field: socketProtos.chat.UserInfo toUser = 4;
     */
    toUser?: UserInfo; // 傳送訊息指定使用者    /**
     * @generated from protobuf field: uint32 createTime = 5;
     */
    createTime: number; // 訊息傳送時間    /**
     * @generated from protobuf field: socketProtos.chat.MessageType msgType = 6;
     */
    msgType: MessageType; // 訊息類別    /**
     * @generated from protobuf field: socketProtos.chat.TgAdvertise tgAdvertise = 7;
     */
    tgAdvertise?: TgAdvertise;
    /**
     * @generated from protobuf field: socketProtos.chat.LiveMatchesLink liveMatchLink = 8;
     */
    liveMatchLink?: LiveMatchesLink; // 直播賽事邀請}
/**
 * @generated from protobuf message socketProtos.chat.TgAdvertise
 */
export interface TgAdvertise {
    /**
     * @generated from protobuf field: string text = 1;
     */
    text: string; // 純文字    /**
     * @generated from protobuf field: string hyperLinkText = 2;
     */
    hyperLinkText: string; // 超連結文字    /**
     * @generated from protobuf field: string hyperLink = 3;
     */
    hyperLink: string; // 超連結網址}
/**
 * @generated from protobuf message socketProtos.chat.LiveMatchesLink
 */
export interface LiveMatchesLink {
    /**
     * @generated from protobuf field: string matchText = 1;
     */
    matchText: string; // 賽事對戰純文字    /**
     * @generated from protobuf field: int32 matchId = 2;
     */
    matchId: number; // 賽事id}
/**
 * HistoryMessageReply
 * 賽事房間歷史訊息 cmd:HistoryMessageReplyCode
 * 離線訊息推送 cmd:OfflinePrivateMessageReplyCode
 *
 * @generated from protobuf message socketProtos.chat.HistoryMessageReply
 */
export interface HistoryMessageReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: repeated socketProtos.chat.Message messages = 3;
     */
    messages: Message[];
    /**
     * @generated from protobuf field: socketProtos.chat.Room room = 4;
     */
    room?: Room;
}
/**
 * @generated from protobuf message socketProtos.chat.UserInfo
 */
export interface UserInfo {
    /**
     * @generated from protobuf field: int32 userId = 1;
     */
    userId: number;
    /**
     * @generated from protobuf field: string userName = 2;
     */
    userName: string; // 帳號    /**
     * @generated from protobuf field: socketProtos.chat.userType userType = 3;
     */
    userType: userType;
    /**
     * @generated from protobuf field: string profilePic = 4;
     */
    profilePic: string;
    /**
     * @generated from protobuf field: string nickName = 5;
     */
    nickName: string; // 暱稱}
/**
 * RoomInfoReply 房間人數及線上會員列表 cmd:RoomInfoReplyCode
 *
 * @generated from protobuf message socketProtos.chat.RoomInfoReply
 */
export interface RoomInfoReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: int32 userCnt = 3;
     */
    userCnt: number; // 房間當前人數    /**
     * @generated from protobuf field: repeated socketProtos.chat.UserInfo onlineList = 4;
     */
    onlineList: UserInfo[]; // 當前在線會員列表    /**
     * @generated from protobuf field: socketProtos.chat.Room room = 5;
     */
    room?: Room;
}
/**
 * RoomUserChangeReply 房間會員進出、人數更新 addUser,minusUser可同時為空 cmd:RoomUserChangeReplyCode
 *
 * @generated from protobuf message socketProtos.chat.RoomUserChangeReply
 */
export interface RoomUserChangeReply {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: int32 userCnt = 3;
     */
    userCnt: number; // 房間當前人數    /**
     * @generated from protobuf field: socketProtos.chat.UserInfo addUser = 4;
     */
    addUser?: UserInfo; // 新進房間的會員    /**
     * @generated from protobuf field: socketProtos.chat.UserInfo minusUser = 5;
     */
    minusUser?: UserInfo; // 離開房間的會員    /**
     * @generated from protobuf field: int32 views = 6;
     */
    views: number; // 累計次數}
/**
 * SearchRoomHistoryMessage 查詢房間歷史訊息 cmd:SearchHistoryMessageReuestCode
 *
 * @generated from protobuf message socketProtos.chat.SearchRoomHistoryMessage
 */
export interface SearchRoomHistoryMessage {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
    /**
     * @generated from protobuf field: string srhMsgId = 3;
     */
    srhMsgId: string; // 訊息唯一key 當為空字串時 回傳最近50筆歷史訊息,有id時 以該id為起點前查詢50筆歷史訊息}
/**
 * @generated from protobuf message socketProtos.chat.BannedSendMessage
 */
export interface BannedSendMessage {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: int32 banEndTime = 2;
     */
    banEndTime: number; // =0時，表示永久禁言    /**
     * @generated from protobuf field: int32 reasonType = 3;
     */
    reasonType: number; // 禁言原因代碼}
/**
 * @generated from protobuf message socketProtos.chat.CloseChatMessage
 */
export interface CloseChatMessage {
    /**
     * @generated from protobuf field: socketProtos.chat.Command command = 1;
     */
    command: Command;
    /**
     * @generated from protobuf field: string roomId = 2;
     */
    roomId: string;
}
/**
 * @generated from protobuf message socketProtos.chat.Room
 */
export interface Room {
    /**
     * @generated from protobuf field: string roomId = 1;
     */
    roomId: string; // 唯一key    /**
     * @generated from protobuf field: socketProtos.chat.roomType roomType = 2;
     */
    roomType: roomType; // 種類    /**
     * @generated from protobuf field: socketProtos.chat.RoomStatusList roomStatus = 3;
     */
    roomStatus: RoomStatusList; // 狀態}
/**
 * @generated from protobuf enum socketProtos.chat.Command
 */
export enum Command {
    /**
     * 系統訊息請忽略 pong
     *
     * @generated from protobuf enum value: system = 0;
     */
    system = 0,
    /**
     * ping請求 回 pong 0
     *
     * @generated from protobuf enum value: pingCode = 9999;
     */
    pingCode = 9999,
    /**
     * 參數錯誤
     *
     * @generated from protobuf enum value: parameterError = 4444;
     */
    parameterError = 4444,
    /**
     * 訂閱賽事房間
     *
     * @generated from protobuf enum value: ConnectRequestCode = 8101;
     */
    ConnectRequestCode = 8101,
    /**
     * 取消訂閱賽事房間 退出房間
     *
     * @generated from protobuf enum value: unSubcribeLiveRoomRequestCode = 8111;
     */
    unSubcribeLiveRoomRequestCode = 8111,
    /**
     * 傳送訊息至房間(賽事、私訊)
     *
     * @generated from protobuf enum value: PushMessageRequestCode = 8201;
     */
    PushMessageRequestCode = 8201,
    /**
     * 歷史聊天訊息
     *
     * @generated from protobuf enum value: HistoryMessageReplyCode = 8102;
     */
    HistoryMessageReplyCode = 8102,
    /**
     * 房間資訊及人數
     *
     * @generated from protobuf enum value: RoomInfoReplyCode = 8103;
     */
    RoomInfoReplyCode = 8103,
    /**
     * 房間人員異動
     *
     * @generated from protobuf enum value: RoomUserChangeReplyCode = 8300;
     */
    RoomUserChangeReplyCode = 8300,
    /**
     * 接收房間訊息
     *
     * @generated from protobuf enum value: NewMessageReplyCode = 8100;
     */
    NewMessageReplyCode = 8100,
    /**
     * 刪除房間訊息
     *
     * @generated from protobuf enum value: DelMessageReplyCode = 8188;
     */
    DelMessageReplyCode = 8188,
    /**
     * 傳送訊息格式文字不符
     *
     * @generated from protobuf enum value: NewMessageErrorReplyCode = 8104;
     */
    NewMessageErrorReplyCode = 8104,
    /**
     * 被禁止發言
     *
     * @generated from protobuf enum value: BannedNoTalkingErrorReplyCode = 8143;
     */
    BannedNoTalkingErrorReplyCode = 8143,
    /**
     * 聊天室已關閉
     *
     * @generated from protobuf enum value: CloseChatReplyCode = 8144;
     */
    CloseChatReplyCode = 8144,
    /**
     * 請求歷史訊息
     *
     * @generated from protobuf enum value: SearchHistoryMessageReuestCode = 8212;
     */
    SearchHistoryMessageReuestCode = 8212,
    /**
     * 離線私聊訊息
     *
     * @generated from protobuf enum value: OfflinePrivateMessageReplyCode = 8113;
     */
    OfflinePrivateMessageReplyCode = 8113
}
/**
 * @generated from protobuf enum socketProtos.chat.newMsgErrorType
 */
export enum newMsgErrorType {
    /**
     * 系統預設
     *
     * @generated from protobuf enum value: successMsg = 0;
     */
    successMsg = 0,
    /**
     * 超過字元長度
     *
     * @generated from protobuf enum value: overLengthText = 8141;
     */
    overLengthText = 8141,
    /**
     * 含有禁止文字、特殊字元、網址等
     *
     * @generated from protobuf enum value: containsProhibitedText = 8142;
     */
    containsProhibitedText = 8142,
    /**
     * 被禁止發言
     *
     * @generated from protobuf enum value: bannedNoTalking = 8143;
     */
    bannedNoTalking = 8143,
    /**
     * 聊天室已關閉
     *
     * @generated from protobuf enum value: closeChat = 8144;
     */
    closeChat = 8144,
    /**
     * 發送訊息過於頻繁
     *
     * @generated from protobuf enum value: sendRateTooOften = 8145;
     */
    sendRateTooOften = 8145,
    /**
     * 使用者權限不足無法傳送訊息
     *
     * @generated from protobuf enum value: insufficientPermissions = 8160;
     */
    insufficientPermissions = 8160
}
/**
 * @generated from protobuf enum socketProtos.chat.MessageType
 */
export enum MessageType {
    /**
     * 不存在
     *
     * @generated from protobuf enum value: errMessage = 0;
     */
    errMessage = 0,
    /**
     * 純文字訊息
     *
     * @generated from protobuf enum value: text = 1;
     */
    text = 1,
    /**
     * 貼圖
     *
     * @generated from protobuf enum value: image = 2;
     */
    image = 2,
    /**
     * 私人訊息，賽事邀請
     *
     * @generated from protobuf enum value: liveMatches = 8;
     */
    liveMatches = 8,
    /**
     * TG推廣
     *
     * @generated from protobuf enum value: tgAdvertise = 9;
     */
    tgAdvertise = 9
}
/**
 * @generated from protobuf enum socketProtos.chat.userType
 */
export enum userType {
    /**
     *
     *
     * @generated from protobuf enum value: none = 0;
     */
    none = 0,
    /**
     * 會員
     *
     * @generated from protobuf enum value: fullMember = 1;
     */
    fullMember = 1,
    /**
     * 訪客
     *
     * @generated from protobuf enum value: guest = 5;
     */
    guest = 5
}
/**
 * @generated from protobuf enum socketProtos.chat.roomType
 */
export enum roomType {
    /**
     * 錯誤
     *
     * @generated from protobuf enum value: errRoom = 0;
     */
    errRoom = 0,
    /**
     * 賽事直播
     *
     * @generated from protobuf enum value: soccerLive = 1;
     */
    soccerLive = 1,
    /**
     * 私人1對1
     *
     * @generated from protobuf enum value: privateRoom = 9;
     */
    privateRoom = 9
}
/**
 * @generated from protobuf enum socketProtos.chat.RoomStatusList
 */
export enum RoomStatusList {
    /**
     * 尚未開始
     *
     * @generated from protobuf enum value: None = 0;
     */
    None = 0,
    /**
     * 開放中
     *
     * @generated from protobuf enum value: Start = 1;
     */
    Start = 1,
    /**
     * 已結束
     *
     * @generated from protobuf enum value: Close = 8;
     */
    Close = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class Connect$Type extends MessageType$<Connect> {
    constructor() {
        super("socketProtos.chat.Connect", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<Connect>): Connect {
        const message = { command: 0, roomId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Connect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Connect): Connect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Connect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.Connect
 */
export const Connect = new Connect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class unSubcribeLiveRoom$Type extends MessageType$<unSubcribeLiveRoom> {
    constructor() {
        super("socketProtos.chat.unSubcribeLiveRoom", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<unSubcribeLiveRoom>): unSubcribeLiveRoom {
        const message = { command: 0, roomId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<unSubcribeLiveRoom>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: unSubcribeLiveRoom): unSubcribeLiveRoom {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: unSubcribeLiveRoom, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.unSubcribeLiveRoom
 */
export const unSubcribeLiveRoom = new unSubcribeLiveRoom$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PushMessage$Type extends MessageType$<PushMessage> {
    constructor() {
        super("socketProtos.chat.PushMessage", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "msg", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "msgType", kind: "enum", T: () => ["socketProtos.chat.MessageType", MessageType] },
            { no: 5, name: "hashUserId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PushMessage>): PushMessage {
        const message = { command: 0, roomId: "", msg: "", msgType: 0, hashUserId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PushMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PushMessage): PushMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* string msg */ 3:
                    message.msg = reader.string();
                    break;
                case /* socketProtos.chat.MessageType msgType */ 4:
                    message.msgType = reader.int32();
                    break;
                case /* int32 hashUserId */ 5:
                    message.hashUserId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PushMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* string msg = 3; */
        if (message.msg !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.msg);
        /* socketProtos.chat.MessageType msgType = 4; */
        if (message.msgType !== 0)
            writer.tag(4, WireType.Varint).int32(message.msgType);
        /* int32 hashUserId = 5; */
        if (message.hashUserId !== 0)
            writer.tag(5, WireType.Varint).int32(message.hashUserId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.PushMessage
 */
export const PushMessage = new PushMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewMessageReply$Type extends MessageType$<NewMessageReply> {
    constructor() {
        super("socketProtos.chat.NewMessageReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "message", T: () => Message },
            { no: 4, name: "room", kind: "message", T: () => Room }
        ]);
    }
    create(value?: PartialMessage<NewMessageReply>): NewMessageReply {
        const message = { command: 0, roomId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewMessageReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewMessageReply): NewMessageReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* socketProtos.chat.Message message */ 3:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* socketProtos.chat.Room room */ 4:
                    message.room = Room.internalBinaryRead(reader, reader.uint32(), options, message.room);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewMessageReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* socketProtos.chat.Message message = 3; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.Room room = 4; */
        if (message.room)
            Room.internalBinaryWrite(message.room, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.NewMessageReply
 */
export const NewMessageReply = new NewMessageReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DelMessageReply$Type extends MessageType$<DelMessageReply> {
    constructor() {
        super("socketProtos.chat.DelMessageReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "msgId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DelMessageReply>): DelMessageReply {
        const message = { command: 0, roomId: "", msgId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DelMessageReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DelMessageReply): DelMessageReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* string msgId */ 3:
                    message.msgId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DelMessageReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* string msgId = 3; */
        if (message.msgId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.msgId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.DelMessageReply
 */
export const DelMessageReply = new DelMessageReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorMessageReply$Type extends MessageType$<ErrorMessageReply> {
    constructor() {
        super("socketProtos.chat.ErrorMessageReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "message", kind: "message", T: () => Message },
            { no: 4, name: "errorCode", kind: "enum", T: () => ["socketProtos.chat.newMsgErrorType", newMsgErrorType] },
            { no: 5, name: "room", kind: "message", T: () => Room }
        ]);
    }
    create(value?: PartialMessage<ErrorMessageReply>): ErrorMessageReply {
        const message = { command: 0, roomId: "", errorCode: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ErrorMessageReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorMessageReply): ErrorMessageReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* socketProtos.chat.Message message */ 3:
                    message.message = Message.internalBinaryRead(reader, reader.uint32(), options, message.message);
                    break;
                case /* socketProtos.chat.newMsgErrorType errorCode */ 4:
                    message.errorCode = reader.int32();
                    break;
                case /* socketProtos.chat.Room room */ 5:
                    message.room = Room.internalBinaryRead(reader, reader.uint32(), options, message.room);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorMessageReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* socketProtos.chat.Message message = 3; */
        if (message.message)
            Message.internalBinaryWrite(message.message, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.newMsgErrorType errorCode = 4; */
        if (message.errorCode !== 0)
            writer.tag(4, WireType.Varint).int32(message.errorCode);
        /* socketProtos.chat.Room room = 5; */
        if (message.room)
            Room.internalBinaryWrite(message.room, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.ErrorMessageReply
 */
export const ErrorMessageReply = new ErrorMessageReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Message$Type extends MessageType$<Message> {
    constructor() {
        super("socketProtos.chat.Message", [
            { no: 1, name: "msgId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "msgText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fromUser", kind: "message", T: () => UserInfo },
            { no: 4, name: "toUser", kind: "message", T: () => UserInfo },
            { no: 5, name: "createTime", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "msgType", kind: "enum", T: () => ["socketProtos.chat.MessageType", MessageType] },
            { no: 7, name: "tgAdvertise", kind: "message", T: () => TgAdvertise },
            { no: 8, name: "liveMatchLink", kind: "message", T: () => LiveMatchesLink }
        ]);
    }
    create(value?: PartialMessage<Message>): Message {
        const message = { msgId: "", msgText: "", createTime: 0, msgType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Message>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Message): Message {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string msgId */ 1:
                    message.msgId = reader.string();
                    break;
                case /* string msgText */ 2:
                    message.msgText = reader.string();
                    break;
                case /* socketProtos.chat.UserInfo fromUser */ 3:
                    message.fromUser = UserInfo.internalBinaryRead(reader, reader.uint32(), options, message.fromUser);
                    break;
                case /* socketProtos.chat.UserInfo toUser */ 4:
                    message.toUser = UserInfo.internalBinaryRead(reader, reader.uint32(), options, message.toUser);
                    break;
                case /* uint32 createTime */ 5:
                    message.createTime = reader.uint32();
                    break;
                case /* socketProtos.chat.MessageType msgType */ 6:
                    message.msgType = reader.int32();
                    break;
                case /* socketProtos.chat.TgAdvertise tgAdvertise */ 7:
                    message.tgAdvertise = TgAdvertise.internalBinaryRead(reader, reader.uint32(), options, message.tgAdvertise);
                    break;
                case /* socketProtos.chat.LiveMatchesLink liveMatchLink */ 8:
                    message.liveMatchLink = LiveMatchesLink.internalBinaryRead(reader, reader.uint32(), options, message.liveMatchLink);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Message, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string msgId = 1; */
        if (message.msgId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.msgId);
        /* string msgText = 2; */
        if (message.msgText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.msgText);
        /* socketProtos.chat.UserInfo fromUser = 3; */
        if (message.fromUser)
            UserInfo.internalBinaryWrite(message.fromUser, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.UserInfo toUser = 4; */
        if (message.toUser)
            UserInfo.internalBinaryWrite(message.toUser, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* uint32 createTime = 5; */
        if (message.createTime !== 0)
            writer.tag(5, WireType.Varint).uint32(message.createTime);
        /* socketProtos.chat.MessageType msgType = 6; */
        if (message.msgType !== 0)
            writer.tag(6, WireType.Varint).int32(message.msgType);
        /* socketProtos.chat.TgAdvertise tgAdvertise = 7; */
        if (message.tgAdvertise)
            TgAdvertise.internalBinaryWrite(message.tgAdvertise, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.LiveMatchesLink liveMatchLink = 8; */
        if (message.liveMatchLink)
            LiveMatchesLink.internalBinaryWrite(message.liveMatchLink, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.Message
 */
export const Message = new Message$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TgAdvertise$Type extends MessageType$<TgAdvertise> {
    constructor() {
        super("socketProtos.chat.TgAdvertise", [
            { no: 1, name: "text", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "hyperLinkText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hyperLink", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<TgAdvertise>): TgAdvertise {
        const message = { text: "", hyperLinkText: "", hyperLink: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TgAdvertise>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TgAdvertise): TgAdvertise {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string text */ 1:
                    message.text = reader.string();
                    break;
                case /* string hyperLinkText */ 2:
                    message.hyperLinkText = reader.string();
                    break;
                case /* string hyperLink */ 3:
                    message.hyperLink = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TgAdvertise, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string text = 1; */
        if (message.text !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.text);
        /* string hyperLinkText = 2; */
        if (message.hyperLinkText !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.hyperLinkText);
        /* string hyperLink = 3; */
        if (message.hyperLink !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.hyperLink);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.TgAdvertise
 */
export const TgAdvertise = new TgAdvertise$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LiveMatchesLink$Type extends MessageType$<LiveMatchesLink> {
    constructor() {
        super("socketProtos.chat.LiveMatchesLink", [
            { no: 1, name: "matchText", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "matchId", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<LiveMatchesLink>): LiveMatchesLink {
        const message = { matchText: "", matchId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LiveMatchesLink>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LiveMatchesLink): LiveMatchesLink {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string matchText */ 1:
                    message.matchText = reader.string();
                    break;
                case /* int32 matchId */ 2:
                    message.matchId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LiveMatchesLink, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string matchText = 1; */
        if (message.matchText !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.matchText);
        /* int32 matchId = 2; */
        if (message.matchId !== 0)
            writer.tag(2, WireType.Varint).int32(message.matchId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.LiveMatchesLink
 */
export const LiveMatchesLink = new LiveMatchesLink$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HistoryMessageReply$Type extends MessageType$<HistoryMessageReply> {
    constructor() {
        super("socketProtos.chat.HistoryMessageReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "messages", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Message },
            { no: 4, name: "room", kind: "message", T: () => Room }
        ]);
    }
    create(value?: PartialMessage<HistoryMessageReply>): HistoryMessageReply {
        const message = { command: 0, roomId: "", messages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HistoryMessageReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HistoryMessageReply): HistoryMessageReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* repeated socketProtos.chat.Message messages */ 3:
                    message.messages.push(Message.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* socketProtos.chat.Room room */ 4:
                    message.room = Room.internalBinaryRead(reader, reader.uint32(), options, message.room);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HistoryMessageReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* repeated socketProtos.chat.Message messages = 3; */
        for (let i = 0; i < message.messages.length; i++)
            Message.internalBinaryWrite(message.messages[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.Room room = 4; */
        if (message.room)
            Room.internalBinaryWrite(message.room, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.HistoryMessageReply
 */
export const HistoryMessageReply = new HistoryMessageReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UserInfo$Type extends MessageType$<UserInfo> {
    constructor() {
        super("socketProtos.chat.UserInfo", [
            { no: 1, name: "userId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "userName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userType", kind: "enum", T: () => ["socketProtos.chat.userType", userType] },
            { no: 4, name: "profilePic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "nickName", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UserInfo>): UserInfo {
        const message = { userId: 0, userName: "", userType: 0, profilePic: "", nickName: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UserInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UserInfo): UserInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 userId */ 1:
                    message.userId = reader.int32();
                    break;
                case /* string userName */ 2:
                    message.userName = reader.string();
                    break;
                case /* socketProtos.chat.userType userType */ 3:
                    message.userType = reader.int32();
                    break;
                case /* string profilePic */ 4:
                    message.profilePic = reader.string();
                    break;
                case /* string nickName */ 5:
                    message.nickName = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UserInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 userId = 1; */
        if (message.userId !== 0)
            writer.tag(1, WireType.Varint).int32(message.userId);
        /* string userName = 2; */
        if (message.userName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.userName);
        /* socketProtos.chat.userType userType = 3; */
        if (message.userType !== 0)
            writer.tag(3, WireType.Varint).int32(message.userType);
        /* string profilePic = 4; */
        if (message.profilePic !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.profilePic);
        /* string nickName = 5; */
        if (message.nickName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.nickName);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.UserInfo
 */
export const UserInfo = new UserInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomInfoReply$Type extends MessageType$<RoomInfoReply> {
    constructor() {
        super("socketProtos.chat.RoomInfoReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userCnt", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "onlineList", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UserInfo },
            { no: 5, name: "room", kind: "message", T: () => Room }
        ]);
    }
    create(value?: PartialMessage<RoomInfoReply>): RoomInfoReply {
        const message = { command: 0, roomId: "", userCnt: 0, onlineList: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomInfoReply): RoomInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* int32 userCnt */ 3:
                    message.userCnt = reader.int32();
                    break;
                case /* repeated socketProtos.chat.UserInfo onlineList */ 4:
                    message.onlineList.push(UserInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* socketProtos.chat.Room room */ 5:
                    message.room = Room.internalBinaryRead(reader, reader.uint32(), options, message.room);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* int32 userCnt = 3; */
        if (message.userCnt !== 0)
            writer.tag(3, WireType.Varint).int32(message.userCnt);
        /* repeated socketProtos.chat.UserInfo onlineList = 4; */
        for (let i = 0; i < message.onlineList.length; i++)
            UserInfo.internalBinaryWrite(message.onlineList[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.Room room = 5; */
        if (message.room)
            Room.internalBinaryWrite(message.room, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.RoomInfoReply
 */
export const RoomInfoReply = new RoomInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomUserChangeReply$Type extends MessageType$<RoomUserChangeReply> {
    constructor() {
        super("socketProtos.chat.RoomUserChangeReply", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "userCnt", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "addUser", kind: "message", T: () => UserInfo },
            { no: 5, name: "minusUser", kind: "message", T: () => UserInfo },
            { no: 6, name: "views", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RoomUserChangeReply>): RoomUserChangeReply {
        const message = { command: 0, roomId: "", userCnt: 0, views: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomUserChangeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomUserChangeReply): RoomUserChangeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* int32 userCnt */ 3:
                    message.userCnt = reader.int32();
                    break;
                case /* socketProtos.chat.UserInfo addUser */ 4:
                    message.addUser = UserInfo.internalBinaryRead(reader, reader.uint32(), options, message.addUser);
                    break;
                case /* socketProtos.chat.UserInfo minusUser */ 5:
                    message.minusUser = UserInfo.internalBinaryRead(reader, reader.uint32(), options, message.minusUser);
                    break;
                case /* int32 views */ 6:
                    message.views = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomUserChangeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* int32 userCnt = 3; */
        if (message.userCnt !== 0)
            writer.tag(3, WireType.Varint).int32(message.userCnt);
        /* socketProtos.chat.UserInfo addUser = 4; */
        if (message.addUser)
            UserInfo.internalBinaryWrite(message.addUser, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* socketProtos.chat.UserInfo minusUser = 5; */
        if (message.minusUser)
            UserInfo.internalBinaryWrite(message.minusUser, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* int32 views = 6; */
        if (message.views !== 0)
            writer.tag(6, WireType.Varint).int32(message.views);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.RoomUserChangeReply
 */
export const RoomUserChangeReply = new RoomUserChangeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRoomHistoryMessage$Type extends MessageType$<SearchRoomHistoryMessage> {
    constructor() {
        super("socketProtos.chat.SearchRoomHistoryMessage", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "srhMsgId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SearchRoomHistoryMessage>): SearchRoomHistoryMessage {
        const message = { command: 0, roomId: "", srhMsgId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchRoomHistoryMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRoomHistoryMessage): SearchRoomHistoryMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                case /* string srhMsgId */ 3:
                    message.srhMsgId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRoomHistoryMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        /* string srhMsgId = 3; */
        if (message.srhMsgId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.srhMsgId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.SearchRoomHistoryMessage
 */
export const SearchRoomHistoryMessage = new SearchRoomHistoryMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BannedSendMessage$Type extends MessageType$<BannedSendMessage> {
    constructor() {
        super("socketProtos.chat.BannedSendMessage", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "banEndTime", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "reasonType", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BannedSendMessage>): BannedSendMessage {
        const message = { command: 0, banEndTime: 0, reasonType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BannedSendMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BannedSendMessage): BannedSendMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* int32 banEndTime */ 2:
                    message.banEndTime = reader.int32();
                    break;
                case /* int32 reasonType */ 3:
                    message.reasonType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BannedSendMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* int32 banEndTime = 2; */
        if (message.banEndTime !== 0)
            writer.tag(2, WireType.Varint).int32(message.banEndTime);
        /* int32 reasonType = 3; */
        if (message.reasonType !== 0)
            writer.tag(3, WireType.Varint).int32(message.reasonType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.BannedSendMessage
 */
export const BannedSendMessage = new BannedSendMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloseChatMessage$Type extends MessageType$<CloseChatMessage> {
    constructor() {
        super("socketProtos.chat.CloseChatMessage", [
            { no: 1, name: "command", kind: "enum", T: () => ["socketProtos.chat.Command", Command] },
            { no: 2, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloseChatMessage>): CloseChatMessage {
        const message = { command: 0, roomId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CloseChatMessage>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloseChatMessage): CloseChatMessage {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* socketProtos.chat.Command command */ 1:
                    message.command = reader.int32();
                    break;
                case /* string roomId */ 2:
                    message.roomId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloseChatMessage, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* socketProtos.chat.Command command = 1; */
        if (message.command !== 0)
            writer.tag(1, WireType.Varint).int32(message.command);
        /* string roomId = 2; */
        if (message.roomId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.CloseChatMessage
 */
export const CloseChatMessage = new CloseChatMessage$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Room$Type extends MessageType$<Room> {
    constructor() {
        super("socketProtos.chat.Room", [
            { no: 1, name: "roomId", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "roomType", kind: "enum", T: () => ["socketProtos.chat.roomType", roomType] },
            { no: 3, name: "roomStatus", kind: "enum", T: () => ["socketProtos.chat.RoomStatusList", RoomStatusList] }
        ]);
    }
    create(value?: PartialMessage<Room>): Room {
        const message = { roomId: "", roomType: 0, roomStatus: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Room>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Room): Room {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string roomId */ 1:
                    message.roomId = reader.string();
                    break;
                case /* socketProtos.chat.roomType roomType */ 2:
                    message.roomType = reader.int32();
                    break;
                case /* socketProtos.chat.RoomStatusList roomStatus */ 3:
                    message.roomStatus = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Room, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string roomId = 1; */
        if (message.roomId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.roomId);
        /* socketProtos.chat.roomType roomType = 2; */
        if (message.roomType !== 0)
            writer.tag(2, WireType.Varint).int32(message.roomType);
        /* socketProtos.chat.RoomStatusList roomStatus = 3; */
        if (message.roomStatus !== 0)
            writer.tag(3, WireType.Varint).int32(message.roomStatus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message socketProtos.chat.Room
 */
export const Room = new Room$Type();
